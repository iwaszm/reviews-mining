---
title: "Comment Classification Demo" 
date: '2025-10-01'
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

```{r , global_options, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, echo = FALSE,message = FALSE ,cache = FALSE, cache.lazy = FALSE)
library(httr)
library(jsonlite)
library(knitr)
library(kableExtra)
library(dplyr)
library(stringr)
library(data.table)
library(highcharter)

# 1. Load Hugging Face API key from environment
hf_key <- Sys.getenv("HF_API_KEY")

# 2. Input review
input_text <- ""

# 3. Define label sets
sentiment_labels <- c("positive", "negative", "neutral")
topic_labels <- c("functionality", "user interface", "ads")

# 4. Define model endpoints
models <- list(
  "A" = "https://router.huggingface.co/hf-inference/models/facebook/bart-large-mnli",
  "B" = "https://router.huggingface.co/hf-inference/models/joeddav/xlm-roberta-large-xnli",
  "C" = "https://router.huggingface.co/hf-inference/models/typeform/distilbert-base-uncased-mnli"
)

# 5. Authentication header
headers <- add_headers(
  Authorization = paste("Bearer", hf_key),
  `Content-Type` = "application/json",
  Accept = "application/json"
)

# 6. Helper: extract top label from zero-shot output
extract_top_label <- function(result) {
  # Case 1: bart-large-mnli / xlm-roberta (flat structure with labels/scores)
  if (!is.null(result$labels) && !is.null(result$scores)) {
    return(result$labels[[which.max(unlist(result$scores))]])
  }
  
  # Case 2: cardiffnlp or similar (list of results with label/score)
  if (is.list(result) && is.list(result[[1]]) && !is.null(result[[1]][[1]]$label)) {
    labels <- sapply(result[[1]], function(x) x$label)
    scores <- sapply(result[[1]], function(x) x$score)
    return(labels[[which.max(scores)]])
  }

  # Case 3: nlptown star ratings (e.g., "3 stars" → map to sentiment)
  if (is.list(result) && is.list(result[[1]]) && grepl("stars?", result[[1]][[1]]$label)) {
    stars <- sapply(result[[1]], function(x) x$label)
    scores <- sapply(result[[1]], function(x) x$score)
    top_label <- stars[[which.max(scores)]]
    
    # Optional: map stars to sentiment
    star_num <- as.numeric(sub(" .*", "", top_label))
    if (is.na(star_num)) return(top_label)
    if (star_num <= 2) return("negative")
    if (star_num == 3) return("neutral")
    return("positive")
  }

  return(NA)
}

extract_top_label <- function(result) {
  # 预检：确保是列表
  if (!is.list(result)) return(NA)
  
  # Case 1: bart-large-mnli / xlm-roberta
  if (!is.null(result$labels) && !is.null(result$scores)) {
    scores <- unlist(result$scores)
    if (length(scores) > 0) {
      return(result$labels[[which.max(scores)]])
    }
  }
  
  # Case 2: cardiffnlp 等嵌套结构
  if (is.list(result[[1]]) && !is.null(result[[1]][[1]]$label)) {
    labels <- sapply(result[[1]], function(x) x$label)
    scores <- sapply(result[[1]], function(x) x$score)
    if (length(scores) > 0) {
      return(labels[[which.max(scores)]])
    }
  }

  # Case 3: nlptown 星级评分
  if (is.list(result[[1]]) && grepl("stars?", result[[1]][[1]]$label)) {
    stars <- sapply(result[[1]], function(x) x$label)
    scores <- sapply(result[[1]], function(x) x$score)
    top_label <- stars[[which.max(scores)]]
    star_num <- as.numeric(sub(" .*", "", top_label))
    if (is.na(star_num)) return(top_label)
    if (star_num <= 2) return("negative")
    if (star_num == 3) return("neutral")
    return("positive")
  }

  return(NA)
}


# 7. Initialize result storage
output_df <- data.frame(
  Model = names(models),
  Sentiment = NA_character_,
  Category = NA_character_,
  stringsAsFactors = FALSE
)
```

This demo explores the use of **Hugging Face zero-shot text classification models** to analyze multilingual user comments (e.g., YouTube).  
Two classification dimensions are focused on:

- **Sentiment**: whether the comment is positive, neutral, or negative  
- **Category**: what the comment refers to (functionality, UI, or ads)

Three pre-trained NLI-based transformer models are used for comparison:

- Model A: `facebook/bart-large-mnli`  
- Model B: `joeddav/xlm-roberta-large-xnli`  
- Model C: `typeform/distilbert-base-uncased-mnli`


```{r model legend}
# Model legend for reference
model_legend <- data.frame(
  Code = names(models),
  Model = c(
  "facebook-bart-large-mnli",
  "joeddav-xlm-roberta-large-xnli",
  "typeform-distilbert-base-uncased-mnli"
  ),
  Description = c(
  "a BART-large sequence-to-sequence model fine-tuned on the Multi-Genre Natural Language Inference (MNLI) dataset, so it can classify pairs of sentences as entailment, neutral, or contradiction. Thanks to this NLI training, it is often used for zero-shot text classification by checking if an input text entails a given label hypothesis (allowing classification into any user-defined categories without additional training)",
  "A multilingual RoBERTa-large model fine-tuned on the XNLI corpus (an NLI dataset in 15 languages). This model performs natural language inference across multiple languages and is intended for zero-shot text classification in those languages, enabling cross-lingual classification (e.g. it can take text in one language and labels in another) without language-specific training",
  "An uncased DistilBERT model (a distilled smaller BERT) fine-tuned on the MultiNLI (MNLI) dataset. This model is designed for zero-shot text classification in English using NLI; being “uncased” means it’s case-insensitive, treating “english” and “English” the same way during classification"
  )
)

kable(model_legend)
```

Following are 10 manually labeled comments, spanning multiple languages, sentiment types, and categories.

```{r sample comments}
comments_dt <- data.table::data.table(
  comment = c(
    # English (8)
    "The video loads fast and never lags. Love it!",                            # positive, functionality
    "The search function works fine, but nothing special.",                      # neutral, functionality
    "I can’t rewind properly anymore, super annoying.",                          # negative, functionality
    "I like how the app looks now, clean and smooth.",                           # positive, user interface
    "I am ok with the UI, it can be better though.",                             # neutral, user interface
    "The layout is messy after the latest update.",                              # negative, user interface
    "Way too many ads these days, it ruins the experience.",                     # negative, ads
    "Ads are skippable now, so it’s not too bad.",                               # neutral, ads
    # German (1)
    "Zu viele nervige Werbungen, es macht keinen Spaß mehr.",                    # negative, ads
    # Chinese (1)
    "功能正常，但感觉有点卡。"                                                  # neutral, functionality
  ),
  language = c("en", "en", "en", "en", "en", "en", "en", "en", "de", "zh"),
  true_sentiment = c("positive", "neutral", "negative", "positive", "neutral", 
                     "negative", "negative", "neutral", "negative", "neutral"),
  true_category = c("functionality", "functionality", "functionality",
                    "user interface", "user interface", "user interface",
                    "ads", "ads", "ads", "functionality")
)

```

Each model classifies each comment for both sentiment and category, correct results are shown in **bold** in the table below.

```{r classification-loop-table}
# Initialize wide result table
results_table <- comments_dt[, .(Comment = comment)]

# Loop through each comment
for (row in 1:nrow(comments_dt)) {
  text_input <- comments_dt$comment[row]
  true_sent <- comments_dt$true_sentiment[row]
  true_cat <- comments_dt$true_category[row]
  
  # Temporary row holder
  row_result <- list()
  
  # Loop through each model
  for (model_code in names(models)) {
    url <- models[[model_code]]
    
    # Sentiment
    body_sent <- list(inputs = text_input, parameters = list(candidate_labels = sentiment_labels))
    res_sent <- POST(url, headers, body = body_sent, encode = "json", timeout(30))
    result_sent <- content(res_sent, as = "parsed", encoding = "UTF-8")
    pred_sent <- extract_top_label(result_sent)
    if (!is.na(pred_sent) && pred_sent == true_sent) {
      pred_sent <- paste0("**", pred_sent, "**")
    }
    
    # Category
    body_cat <- list(inputs = text_input, parameters = list(candidate_labels = topic_labels))
    res_cat <- POST(url, headers, body = body_cat, encode = "json")
    result_cat <- content(res_cat, as = "parsed", encoding = "UTF-8")
    pred_cat <- extract_top_label(result_cat)
    if (!is.na(pred_cat) && pred_cat == true_cat) {
      pred_cat <- paste0("**", pred_cat, "**")
    }
    
    # Add to row_result
    row_result[[paste0("Sent_", model_code)]] <- pred_sent
    row_result[[paste0("Cat_", model_code)]] <- pred_cat
  }
  
  # Append to results_table
  results_table[row, names(row_result) := row_result]
}

# Reorder for display: Sentiment (A/B/C), Category (A/B/C)
results_table_display <- 
  results_table[, .( Comment, `A` = Sent_A, `B` = Sent_B, `C` = Sent_C, `A` = Cat_A, `B` = Cat_B, `C` = Cat_C )]

# creat double header table
kable(results_table_display, format = "html", align="c", escape = FALSE) %>%
  add_header_above(c(" " = 1, "Sentiment" = 3, "Category" = 3)) %>%
  kable_styling(bootstrap_options = c("condensed", "hover", "striped"), full_width = FALSE) 
```



```{r model-score-barplot}
score_table <- data.table(Model = names(models), Sentiment = 0, Category = 0)

# score calculation
for (model_code in names(models)) {
  sent_col <- paste0("Sent_", model_code)
  cat_col <- paste0("Cat_", model_code)
  
  score_table[Model == model_code, Sentiment := sum(str_detect(results_table[[sent_col]], "\\*\\*"))]
  score_table[Model == model_code, Category := sum(str_detect(results_table[[cat_col]], "\\*\\*"))]
}

score_long <- melt(score_table, id.vars = "Model", variable.name = "Dimension", value.name = "Score")
score_wide <- dcast(score_long, Dimension ~ Model, value.var = "Score")

# Google-like colors
google_colors <- c("#4285F4", "#FF8C42", "#F4B400")

# highcharter plot
hc <- highchart() %>%
  hc_chart(type = "column") %>%
  hc_title(text = "Classification Performance Across Three Models") %>%
  hc_subtitle(text = "Sentiment: Model A performs better  |  Category: Model A & B perform better") %>%
  hc_xAxis(categories = score_wide$Dimension) %>%
  hc_yAxis(visible = FALSE) %>%
  hc_plotOptions(column = list(
    dataLabels = list(
      enabled = TRUE,
      inside = TRUE,
      color = "#FFFFFF",
      verticalAlign = "top",
      align = "center", 
      formatter = JS("
        function() {
          return '<span style=\"font-size:10px;\">Model ' + this.series.name + '</span><br>' +
                 '<span style=\"font-size:16px;font-weight:bold\">' + this.y + '/10</span>';
        }
      "),
      style = list(fontWeight = "bold")
    )
  )) %>%
  hc_add_series(name = "A", data = score_wide$A, color = google_colors[1], showInLegend = FALSE) %>%
  hc_add_series(name = "B", data = score_wide$B, color = google_colors[2], showInLegend = FALSE) %>%
  hc_add_series(name = "C", data = score_wide$C, color = google_colors[3], showInLegend = FALSE) %>%
  hc_tooltip(enabled = FALSE)

hc
```

